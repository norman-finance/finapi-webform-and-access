import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import date
from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from finapi_access.models.account import Account
from finapi_access.models.account_list import AccountList
from finapi_access.models.account_params import AccountParams
from finapi_access.models.daily_balance_list import DailyBalanceList
from finapi_access.models.identifier_list import IdentifierList

from finapi_access.api_client import ApiClient, RequestSerialized
from finapi_access.api_response import ApiResponse
from finapi_access.rest import RESTResponseType


class AccountsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def delete_account(
        self,
        id: Annotated[StrictInt, Field(description="Identifier of the account to delete")],
        psu_ip_address: Annotated[Optional[StrictStr], Field(description="The IP address of the user's device. This header will be forwarded to the bank on XS2A requests. It has to be an IPv4 address, as some banks cannot work with IPv6 addresses. If a non-IPv4 address is passed, we will replace the value with our own IPv4 address as a fallback.")] = None,
        psu_device_os: Annotated[Optional[StrictStr], Field(description="The user's device and/or operating system identification. This header will be forwarded to the bank on XS2A requests.")] = None,
        psu_user_agent: Annotated[Optional[StrictStr], Field(description="The user's web browser or other client device identification. This header will be forwarded to the bank on XS2A requests.")] = None,
        x_http_method_override: Annotated[Optional[StrictStr], Field(description="Some HTTP clients do not support the HTTP methods PATCH or DELETE. If you are using such a client in your application, you can use a POST request instead with this header indicating the originally intended HTTP method. POST Requests having this  header set will be treated either as PATCH or DELETE by the finAPI servers.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete an account

        Delete a single bank account of the user that is authorized by the access_token, including its transactions and balance data. Must pass the account's identifier and the user's access_token.<br/><br/>Notes: <br/>&bull; You cannot delete an account while the bank connection that it relates to is currently in the process of import, update, or transaction categorization.<br/>&bull; If the deleted account was connected to interfaces that no other account of the same bank connection is supporting, then those interfaces will be removed from the bank connection as well.<br/>&bull; When the last remaining account of a bank connection gets deleted, then the entire bank connection will get deleted as well, including consents on the bank's side.<br/>&bull; All notification rules that are connected to the account will get adjusted so that they no longer have this account listed. Notification rules that are connected to just this account (and no other accounts) will get deleted altogether.<br/>&bull; If a consent will get deleted by this service, it's not guaranteed that the consent will also get deleted on the bank's side, as not all banks may support this. Also errors during bank consent deletion will be ignored, so the service won't fail due to this.<br/><br/><b>ATTENTION:</b> For the deletion of XS2A consents, additional headers should be included in the request if the end user is involved. Please refer to the <a href='#general-user-metadata'>User metadata</a> section under 'General Information' of the API documentation.

        :param id: Identifier of the account to delete (required)
        :type id: int
        :param psu_ip_address: The IP address of the user's device. This header will be forwarded to the bank on XS2A requests. It has to be an IPv4 address, as some banks cannot work with IPv6 addresses. If a non-IPv4 address is passed, we will replace the value with our own IPv4 address as a fallback.
        :type psu_ip_address: str
        :param psu_device_os: The user's device and/or operating system identification. This header will be forwarded to the bank on XS2A requests.
        :type psu_device_os: str
        :param psu_user_agent: The user's web browser or other client device identification. This header will be forwarded to the bank on XS2A requests.
        :type psu_user_agent: str
        :param x_http_method_override: Some HTTP clients do not support the HTTP methods PATCH or DELETE. If you are using such a client in your application, you can use a POST request instead with this header indicating the originally intended HTTP method. POST Requests having this  header set will be treated either as PATCH or DELETE by the finAPI servers.
        :type x_http_method_override: str
        :param x_request_id: With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_account_serialize(
            id=id,
            psu_ip_address=psu_ip_address,
            psu_device_os=psu_device_os,
            psu_user_agent=psu_user_agent,
            x_http_method_override=x_http_method_override,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "ErrorMessage",
            '401': "BadCredentialsError",
            '403': "ErrorMessage",
            '404': "ErrorMessage",
            '423': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_account_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="Identifier of the account to delete")],
        psu_ip_address: Annotated[Optional[StrictStr], Field(description="The IP address of the user's device. This header will be forwarded to the bank on XS2A requests. It has to be an IPv4 address, as some banks cannot work with IPv6 addresses. If a non-IPv4 address is passed, we will replace the value with our own IPv4 address as a fallback.")] = None,
        psu_device_os: Annotated[Optional[StrictStr], Field(description="The user's device and/or operating system identification. This header will be forwarded to the bank on XS2A requests.")] = None,
        psu_user_agent: Annotated[Optional[StrictStr], Field(description="The user's web browser or other client device identification. This header will be forwarded to the bank on XS2A requests.")] = None,
        x_http_method_override: Annotated[Optional[StrictStr], Field(description="Some HTTP clients do not support the HTTP methods PATCH or DELETE. If you are using such a client in your application, you can use a POST request instead with this header indicating the originally intended HTTP method. POST Requests having this  header set will be treated either as PATCH or DELETE by the finAPI servers.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete an account

        Delete a single bank account of the user that is authorized by the access_token, including its transactions and balance data. Must pass the account's identifier and the user's access_token.<br/><br/>Notes: <br/>&bull; You cannot delete an account while the bank connection that it relates to is currently in the process of import, update, or transaction categorization.<br/>&bull; If the deleted account was connected to interfaces that no other account of the same bank connection is supporting, then those interfaces will be removed from the bank connection as well.<br/>&bull; When the last remaining account of a bank connection gets deleted, then the entire bank connection will get deleted as well, including consents on the bank's side.<br/>&bull; All notification rules that are connected to the account will get adjusted so that they no longer have this account listed. Notification rules that are connected to just this account (and no other accounts) will get deleted altogether.<br/>&bull; If a consent will get deleted by this service, it's not guaranteed that the consent will also get deleted on the bank's side, as not all banks may support this. Also errors during bank consent deletion will be ignored, so the service won't fail due to this.<br/><br/><b>ATTENTION:</b> For the deletion of XS2A consents, additional headers should be included in the request if the end user is involved. Please refer to the <a href='#general-user-metadata'>User metadata</a> section under 'General Information' of the API documentation.

        :param id: Identifier of the account to delete (required)
        :type id: int
        :param psu_ip_address: The IP address of the user's device. This header will be forwarded to the bank on XS2A requests. It has to be an IPv4 address, as some banks cannot work with IPv6 addresses. If a non-IPv4 address is passed, we will replace the value with our own IPv4 address as a fallback.
        :type psu_ip_address: str
        :param psu_device_os: The user's device and/or operating system identification. This header will be forwarded to the bank on XS2A requests.
        :type psu_device_os: str
        :param psu_user_agent: The user's web browser or other client device identification. This header will be forwarded to the bank on XS2A requests.
        :type psu_user_agent: str
        :param x_http_method_override: Some HTTP clients do not support the HTTP methods PATCH or DELETE. If you are using such a client in your application, you can use a POST request instead with this header indicating the originally intended HTTP method. POST Requests having this  header set will be treated either as PATCH or DELETE by the finAPI servers.
        :type x_http_method_override: str
        :param x_request_id: With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_account_serialize(
            id=id,
            psu_ip_address=psu_ip_address,
            psu_device_os=psu_device_os,
            psu_user_agent=psu_user_agent,
            x_http_method_override=x_http_method_override,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "ErrorMessage",
            '401': "BadCredentialsError",
            '403': "ErrorMessage",
            '404': "ErrorMessage",
            '423': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_account_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="Identifier of the account to delete")],
        psu_ip_address: Annotated[Optional[StrictStr], Field(description="The IP address of the user's device. This header will be forwarded to the bank on XS2A requests. It has to be an IPv4 address, as some banks cannot work with IPv6 addresses. If a non-IPv4 address is passed, we will replace the value with our own IPv4 address as a fallback.")] = None,
        psu_device_os: Annotated[Optional[StrictStr], Field(description="The user's device and/or operating system identification. This header will be forwarded to the bank on XS2A requests.")] = None,
        psu_user_agent: Annotated[Optional[StrictStr], Field(description="The user's web browser or other client device identification. This header will be forwarded to the bank on XS2A requests.")] = None,
        x_http_method_override: Annotated[Optional[StrictStr], Field(description="Some HTTP clients do not support the HTTP methods PATCH or DELETE. If you are using such a client in your application, you can use a POST request instead with this header indicating the originally intended HTTP method. POST Requests having this  header set will be treated either as PATCH or DELETE by the finAPI servers.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete an account

        Delete a single bank account of the user that is authorized by the access_token, including its transactions and balance data. Must pass the account's identifier and the user's access_token.<br/><br/>Notes: <br/>&bull; You cannot delete an account while the bank connection that it relates to is currently in the process of import, update, or transaction categorization.<br/>&bull; If the deleted account was connected to interfaces that no other account of the same bank connection is supporting, then those interfaces will be removed from the bank connection as well.<br/>&bull; When the last remaining account of a bank connection gets deleted, then the entire bank connection will get deleted as well, including consents on the bank's side.<br/>&bull; All notification rules that are connected to the account will get adjusted so that they no longer have this account listed. Notification rules that are connected to just this account (and no other accounts) will get deleted altogether.<br/>&bull; If a consent will get deleted by this service, it's not guaranteed that the consent will also get deleted on the bank's side, as not all banks may support this. Also errors during bank consent deletion will be ignored, so the service won't fail due to this.<br/><br/><b>ATTENTION:</b> For the deletion of XS2A consents, additional headers should be included in the request if the end user is involved. Please refer to the <a href='#general-user-metadata'>User metadata</a> section under 'General Information' of the API documentation.

        :param id: Identifier of the account to delete (required)
        :type id: int
        :param psu_ip_address: The IP address of the user's device. This header will be forwarded to the bank on XS2A requests. It has to be an IPv4 address, as some banks cannot work with IPv6 addresses. If a non-IPv4 address is passed, we will replace the value with our own IPv4 address as a fallback.
        :type psu_ip_address: str
        :param psu_device_os: The user's device and/or operating system identification. This header will be forwarded to the bank on XS2A requests.
        :type psu_device_os: str
        :param psu_user_agent: The user's web browser or other client device identification. This header will be forwarded to the bank on XS2A requests.
        :type psu_user_agent: str
        :param x_http_method_override: Some HTTP clients do not support the HTTP methods PATCH or DELETE. If you are using such a client in your application, you can use a POST request instead with this header indicating the originally intended HTTP method. POST Requests having this  header set will be treated either as PATCH or DELETE by the finAPI servers.
        :type x_http_method_override: str
        :param x_request_id: With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_account_serialize(
            id=id,
            psu_ip_address=psu_ip_address,
            psu_device_os=psu_device_os,
            psu_user_agent=psu_user_agent,
            x_http_method_override=x_http_method_override,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '400': "ErrorMessage",
            '401': "BadCredentialsError",
            '403': "ErrorMessage",
            '404': "ErrorMessage",
            '423': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_account_serialize(
        self,
        id,
        psu_ip_address,
        psu_device_os,
        psu_user_agent,
        x_http_method_override,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        if psu_ip_address is not None:
            _header_params['PSU-IP-Address'] = psu_ip_address
        if psu_device_os is not None:
            _header_params['PSU-Device-OS'] = psu_device_os
        if psu_user_agent is not None:
            _header_params['PSU-User-Agent'] = psu_user_agent
        if x_http_method_override is not None:
            _header_params['X-HTTP-Method-Override'] = x_http_method_override
        if x_request_id is not None:
            _header_params['X-Request-Id'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'finapi_auth', 
            'finapi_auth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/accounts/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_all_accounts(
        self,
        psu_ip_address: Annotated[Optional[StrictStr], Field(description="The IP address of the user's device. This header will be forwarded to the bank on XS2A requests. It has to be an IPv4 address, as some banks cannot work with IPv6 addresses. If a non-IPv4 address is passed, we will replace the value with our own IPv4 address as a fallback.")] = None,
        psu_device_os: Annotated[Optional[StrictStr], Field(description="The user's device and/or operating system identification. This header will be forwarded to the bank on XS2A requests.")] = None,
        psu_user_agent: Annotated[Optional[StrictStr], Field(description="The user's web browser or other client device identification. This header will be forwarded to the bank on XS2A requests.")] = None,
        x_http_method_override: Annotated[Optional[StrictStr], Field(description="Some HTTP clients do not support the HTTP methods PATCH or DELETE. If you are using such a client in your application, you can use a POST request instead with this header indicating the originally intended HTTP method. POST Requests having this  header set will be treated either as PATCH or DELETE by the finAPI servers.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IdentifierList:
        """Delete all accounts

        Delete all accounts of the user that is authorized by the access_token, including all transactions and balance data. Must pass the user's access_token.<br/><br/>Notes: <br/>&bull; Deleting all of the user's accounts also deletes all of his bank connections, including consents on the bank's side.<br/>&bull; All notification rules that are connected to any specific accounts will get deleted as well.<br/>&bull; If at least one of the user's bank connections in currently in the process of import, update, or transaction categorization, then this service will perform no action at all.<br/>&bull; If a consent will get deleted by this service, it's not guaranteed that the consent will also get deleted on the bank's side, as not all banks may support this. Also errors during bank consent deletion will be ignored, so the service won't fail due to this.<br/><br/><b>ATTENTION:</b> For the deletion of XS2A consents, additional headers should be included in the request if the end user is involved. Please refer to the <a href='#general-user-metadata'>User metadata</a> section under 'General Information' of the API documentation.

        :param psu_ip_address: The IP address of the user's device. This header will be forwarded to the bank on XS2A requests. It has to be an IPv4 address, as some banks cannot work with IPv6 addresses. If a non-IPv4 address is passed, we will replace the value with our own IPv4 address as a fallback.
        :type psu_ip_address: str
        :param psu_device_os: The user's device and/or operating system identification. This header will be forwarded to the bank on XS2A requests.
        :type psu_device_os: str
        :param psu_user_agent: The user's web browser or other client device identification. This header will be forwarded to the bank on XS2A requests.
        :type psu_user_agent: str
        :param x_http_method_override: Some HTTP clients do not support the HTTP methods PATCH or DELETE. If you are using such a client in your application, you can use a POST request instead with this header indicating the originally intended HTTP method. POST Requests having this  header set will be treated either as PATCH or DELETE by the finAPI servers.
        :type x_http_method_override: str
        :param x_request_id: With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_all_accounts_serialize(
            psu_ip_address=psu_ip_address,
            psu_device_os=psu_device_os,
            psu_user_agent=psu_user_agent,
            x_http_method_override=x_http_method_override,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IdentifierList",
            '401': "BadCredentialsError",
            '403': "ErrorMessage",
            '423': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_all_accounts_with_http_info(
        self,
        psu_ip_address: Annotated[Optional[StrictStr], Field(description="The IP address of the user's device. This header will be forwarded to the bank on XS2A requests. It has to be an IPv4 address, as some banks cannot work with IPv6 addresses. If a non-IPv4 address is passed, we will replace the value with our own IPv4 address as a fallback.")] = None,
        psu_device_os: Annotated[Optional[StrictStr], Field(description="The user's device and/or operating system identification. This header will be forwarded to the bank on XS2A requests.")] = None,
        psu_user_agent: Annotated[Optional[StrictStr], Field(description="The user's web browser or other client device identification. This header will be forwarded to the bank on XS2A requests.")] = None,
        x_http_method_override: Annotated[Optional[StrictStr], Field(description="Some HTTP clients do not support the HTTP methods PATCH or DELETE. If you are using such a client in your application, you can use a POST request instead with this header indicating the originally intended HTTP method. POST Requests having this  header set will be treated either as PATCH or DELETE by the finAPI servers.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IdentifierList]:
        """Delete all accounts

        Delete all accounts of the user that is authorized by the access_token, including all transactions and balance data. Must pass the user's access_token.<br/><br/>Notes: <br/>&bull; Deleting all of the user's accounts also deletes all of his bank connections, including consents on the bank's side.<br/>&bull; All notification rules that are connected to any specific accounts will get deleted as well.<br/>&bull; If at least one of the user's bank connections in currently in the process of import, update, or transaction categorization, then this service will perform no action at all.<br/>&bull; If a consent will get deleted by this service, it's not guaranteed that the consent will also get deleted on the bank's side, as not all banks may support this. Also errors during bank consent deletion will be ignored, so the service won't fail due to this.<br/><br/><b>ATTENTION:</b> For the deletion of XS2A consents, additional headers should be included in the request if the end user is involved. Please refer to the <a href='#general-user-metadata'>User metadata</a> section under 'General Information' of the API documentation.

        :param psu_ip_address: The IP address of the user's device. This header will be forwarded to the bank on XS2A requests. It has to be an IPv4 address, as some banks cannot work with IPv6 addresses. If a non-IPv4 address is passed, we will replace the value with our own IPv4 address as a fallback.
        :type psu_ip_address: str
        :param psu_device_os: The user's device and/or operating system identification. This header will be forwarded to the bank on XS2A requests.
        :type psu_device_os: str
        :param psu_user_agent: The user's web browser or other client device identification. This header will be forwarded to the bank on XS2A requests.
        :type psu_user_agent: str
        :param x_http_method_override: Some HTTP clients do not support the HTTP methods PATCH or DELETE. If you are using such a client in your application, you can use a POST request instead with this header indicating the originally intended HTTP method. POST Requests having this  header set will be treated either as PATCH or DELETE by the finAPI servers.
        :type x_http_method_override: str
        :param x_request_id: With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_all_accounts_serialize(
            psu_ip_address=psu_ip_address,
            psu_device_os=psu_device_os,
            psu_user_agent=psu_user_agent,
            x_http_method_override=x_http_method_override,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IdentifierList",
            '401': "BadCredentialsError",
            '403': "ErrorMessage",
            '423': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_all_accounts_without_preload_content(
        self,
        psu_ip_address: Annotated[Optional[StrictStr], Field(description="The IP address of the user's device. This header will be forwarded to the bank on XS2A requests. It has to be an IPv4 address, as some banks cannot work with IPv6 addresses. If a non-IPv4 address is passed, we will replace the value with our own IPv4 address as a fallback.")] = None,
        psu_device_os: Annotated[Optional[StrictStr], Field(description="The user's device and/or operating system identification. This header will be forwarded to the bank on XS2A requests.")] = None,
        psu_user_agent: Annotated[Optional[StrictStr], Field(description="The user's web browser or other client device identification. This header will be forwarded to the bank on XS2A requests.")] = None,
        x_http_method_override: Annotated[Optional[StrictStr], Field(description="Some HTTP clients do not support the HTTP methods PATCH or DELETE. If you are using such a client in your application, you can use a POST request instead with this header indicating the originally intended HTTP method. POST Requests having this  header set will be treated either as PATCH or DELETE by the finAPI servers.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete all accounts

        Delete all accounts of the user that is authorized by the access_token, including all transactions and balance data. Must pass the user's access_token.<br/><br/>Notes: <br/>&bull; Deleting all of the user's accounts also deletes all of his bank connections, including consents on the bank's side.<br/>&bull; All notification rules that are connected to any specific accounts will get deleted as well.<br/>&bull; If at least one of the user's bank connections in currently in the process of import, update, or transaction categorization, then this service will perform no action at all.<br/>&bull; If a consent will get deleted by this service, it's not guaranteed that the consent will also get deleted on the bank's side, as not all banks may support this. Also errors during bank consent deletion will be ignored, so the service won't fail due to this.<br/><br/><b>ATTENTION:</b> For the deletion of XS2A consents, additional headers should be included in the request if the end user is involved. Please refer to the <a href='#general-user-metadata'>User metadata</a> section under 'General Information' of the API documentation.

        :param psu_ip_address: The IP address of the user's device. This header will be forwarded to the bank on XS2A requests. It has to be an IPv4 address, as some banks cannot work with IPv6 addresses. If a non-IPv4 address is passed, we will replace the value with our own IPv4 address as a fallback.
        :type psu_ip_address: str
        :param psu_device_os: The user's device and/or operating system identification. This header will be forwarded to the bank on XS2A requests.
        :type psu_device_os: str
        :param psu_user_agent: The user's web browser or other client device identification. This header will be forwarded to the bank on XS2A requests.
        :type psu_user_agent: str
        :param x_http_method_override: Some HTTP clients do not support the HTTP methods PATCH or DELETE. If you are using such a client in your application, you can use a POST request instead with this header indicating the originally intended HTTP method. POST Requests having this  header set will be treated either as PATCH or DELETE by the finAPI servers.
        :type x_http_method_override: str
        :param x_request_id: With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_all_accounts_serialize(
            psu_ip_address=psu_ip_address,
            psu_device_os=psu_device_os,
            psu_user_agent=psu_user_agent,
            x_http_method_override=x_http_method_override,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IdentifierList",
            '401': "BadCredentialsError",
            '403': "ErrorMessage",
            '423': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_all_accounts_serialize(
        self,
        psu_ip_address,
        psu_device_os,
        psu_user_agent,
        x_http_method_override,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if psu_ip_address is not None:
            _header_params['PSU-IP-Address'] = psu_ip_address
        if psu_device_os is not None:
            _header_params['PSU-Device-OS'] = psu_device_os
        if psu_user_agent is not None:
            _header_params['PSU-User-Agent'] = psu_user_agent
        if x_http_method_override is not None:
            _header_params['X-HTTP-Method-Override'] = x_http_method_override
        if x_request_id is not None:
            _header_params['X-Request-Id'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'finapi_auth', 
            'finapi_auth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/accounts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def edit_account(
        self,
        id: Annotated[StrictInt, Field(description="Identifier of the account to edit")],
        account_params: Annotated[AccountParams, Field(description="New account name and/or type and/or 'isNew' flag")],
        x_http_method_override: Annotated[Optional[StrictStr], Field(description="Some HTTP clients do not support the HTTP methods PATCH or DELETE. If you are using such a client in your application, you can use a POST request instead with this header indicating the originally intended HTTP method. POST Requests having this  header set will be treated either as PATCH or DELETE by the finAPI servers.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Account:
        """Edit an account

        Change the name and/or the type and/or the 'isNew' flag of a single bank account of the user that is authorized by the access_token. Must pass the account's identifier, the account's new name and/or type and/or 'isNew' flag, and the user's access_token.

        :param id: Identifier of the account to edit (required)
        :type id: int
        :param account_params: New account name and/or type and/or 'isNew' flag (required)
        :type account_params: AccountParams
        :param x_http_method_override: Some HTTP clients do not support the HTTP methods PATCH or DELETE. If you are using such a client in your application, you can use a POST request instead with this header indicating the originally intended HTTP method. POST Requests having this  header set will be treated either as PATCH or DELETE by the finAPI servers.
        :type x_http_method_override: str
        :param x_request_id: With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._edit_account_serialize(
            id=id,
            account_params=account_params,
            x_http_method_override=x_http_method_override,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Account",
            '400': "ErrorMessage",
            '401': "BadCredentialsError",
            '403': "ErrorMessage",
            '404': "ErrorMessage",
            '423': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def edit_account_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="Identifier of the account to edit")],
        account_params: Annotated[AccountParams, Field(description="New account name and/or type and/or 'isNew' flag")],
        x_http_method_override: Annotated[Optional[StrictStr], Field(description="Some HTTP clients do not support the HTTP methods PATCH or DELETE. If you are using such a client in your application, you can use a POST request instead with this header indicating the originally intended HTTP method. POST Requests having this  header set will be treated either as PATCH or DELETE by the finAPI servers.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Account]:
        """Edit an account

        Change the name and/or the type and/or the 'isNew' flag of a single bank account of the user that is authorized by the access_token. Must pass the account's identifier, the account's new name and/or type and/or 'isNew' flag, and the user's access_token.

        :param id: Identifier of the account to edit (required)
        :type id: int
        :param account_params: New account name and/or type and/or 'isNew' flag (required)
        :type account_params: AccountParams
        :param x_http_method_override: Some HTTP clients do not support the HTTP methods PATCH or DELETE. If you are using such a client in your application, you can use a POST request instead with this header indicating the originally intended HTTP method. POST Requests having this  header set will be treated either as PATCH or DELETE by the finAPI servers.
        :type x_http_method_override: str
        :param x_request_id: With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._edit_account_serialize(
            id=id,
            account_params=account_params,
            x_http_method_override=x_http_method_override,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Account",
            '400': "ErrorMessage",
            '401': "BadCredentialsError",
            '403': "ErrorMessage",
            '404': "ErrorMessage",
            '423': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def edit_account_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="Identifier of the account to edit")],
        account_params: Annotated[AccountParams, Field(description="New account name and/or type and/or 'isNew' flag")],
        x_http_method_override: Annotated[Optional[StrictStr], Field(description="Some HTTP clients do not support the HTTP methods PATCH or DELETE. If you are using such a client in your application, you can use a POST request instead with this header indicating the originally intended HTTP method. POST Requests having this  header set will be treated either as PATCH or DELETE by the finAPI servers.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Edit an account

        Change the name and/or the type and/or the 'isNew' flag of a single bank account of the user that is authorized by the access_token. Must pass the account's identifier, the account's new name and/or type and/or 'isNew' flag, and the user's access_token.

        :param id: Identifier of the account to edit (required)
        :type id: int
        :param account_params: New account name and/or type and/or 'isNew' flag (required)
        :type account_params: AccountParams
        :param x_http_method_override: Some HTTP clients do not support the HTTP methods PATCH or DELETE. If you are using such a client in your application, you can use a POST request instead with this header indicating the originally intended HTTP method. POST Requests having this  header set will be treated either as PATCH or DELETE by the finAPI servers.
        :type x_http_method_override: str
        :param x_request_id: With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._edit_account_serialize(
            id=id,
            account_params=account_params,
            x_http_method_override=x_http_method_override,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Account",
            '400': "ErrorMessage",
            '401': "BadCredentialsError",
            '403': "ErrorMessage",
            '404': "ErrorMessage",
            '423': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _edit_account_serialize(
        self,
        id,
        account_params,
        x_http_method_override,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        if x_http_method_override is not None:
            _header_params['X-HTTP-Method-Override'] = x_http_method_override
        if x_request_id is not None:
            _header_params['X-Request-Id'] = x_request_id
        # process the form parameters
        # process the body parameter
        if account_params is not None:
            _body_params = account_params


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'finapi_auth', 
            'finapi_auth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/accounts/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_account(
        self,
        id: Annotated[StrictInt, Field(description="Identifier of requested account")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Account:
        """Get an account

        Get a single bank account of the user that is authorized by the access_token. Must pass the account's identifier and the user's access_token.

        :param id: Identifier of requested account (required)
        :type id: int
        :param x_request_id: With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_account_serialize(
            id=id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Account",
            '400': "ErrorMessage",
            '401': "BadCredentialsError",
            '403': "ErrorMessage",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_account_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="Identifier of requested account")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Account]:
        """Get an account

        Get a single bank account of the user that is authorized by the access_token. Must pass the account's identifier and the user's access_token.

        :param id: Identifier of requested account (required)
        :type id: int
        :param x_request_id: With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_account_serialize(
            id=id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Account",
            '400': "ErrorMessage",
            '401': "BadCredentialsError",
            '403': "ErrorMessage",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_account_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="Identifier of requested account")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get an account

        Get a single bank account of the user that is authorized by the access_token. Must pass the account's identifier and the user's access_token.

        :param id: Identifier of requested account (required)
        :type id: int
        :param x_request_id: With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_account_serialize(
            id=id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Account",
            '400': "ErrorMessage",
            '401': "BadCredentialsError",
            '403': "ErrorMessage",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_account_serialize(
        self,
        id,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-Id'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'finapi_auth', 
            'finapi_auth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/accounts/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_and_search_all_accounts(
        self,
        ids: Annotated[Optional[List[StrictInt]], Field(description="A comma-separated list of account identifiers. If specified, then only accounts whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.")] = None,
        search: Annotated[Optional[StrictStr], Field(description="If specified, then only those accounts will be contained in the result whose 'accountName', 'iban', 'accountNumber' or 'subAccountNumber' contains the given search string (the matching works case-insensitive). If no accounts contain the search string in any of these fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields for an account to get included into the result.")] = None,
        account_types: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of account types. If specified, then only accounts that relate to the given types will be regarded. If not specified, then all accounts will be regarded.")] = None,
        bank_connection_ids: Annotated[Optional[List[StrictInt]], Field(description="A comma-separated list of bank connection identifiers. If specified, then only accounts that relate to the given bank connections will be regarded. If not specified, then all accounts will be regarded.")] = None,
        min_last_successful_update: Annotated[Optional[date], Field(description="<strong>Format:</strong> 'YYYY-MM-DD'<br/>Lower bound for an account's last successful update date, e.g. '2016-01-01'. If specified, then an account will only be regarded if any of its interfaces has a 'lastSuccessfulUpdate' that is equal to or later than the given date.")] = None,
        max_last_successful_update: Annotated[Optional[date], Field(description="<strong>Format:</strong> 'YYYY-MM-DD'<br/>Upper bound for an account's last successful update date, e.g. '2016-01-01'. If specified, then an account will only be regarded if any of its interfaces has a 'lastSuccessfulUpdate' that is equal to or earlier than the given date.")] = None,
        min_balance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="If specified, then only accounts whose balance is equal to or greater than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95")] = None,
        max_balance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="If specified, then only accounts whose balance is equal to or less than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AccountList:
        """Get and search all accounts

        Get bank accounts of the user that is authorized by the access_token. Must pass the user's access_token. You can set optional search criteria to get only those bank accounts that you are interested in. If you do not specify any search criteria, then this service functions as a 'get all' service.

        :param ids: A comma-separated list of account identifiers. If specified, then only accounts whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
        :type ids: List[int]
        :param search: If specified, then only those accounts will be contained in the result whose 'accountName', 'iban', 'accountNumber' or 'subAccountNumber' contains the given search string (the matching works case-insensitive). If no accounts contain the search string in any of these fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields for an account to get included into the result.
        :type search: str
        :param account_types: A comma-separated list of account types. If specified, then only accounts that relate to the given types will be regarded. If not specified, then all accounts will be regarded.
        :type account_types: List[str]
        :param bank_connection_ids: A comma-separated list of bank connection identifiers. If specified, then only accounts that relate to the given bank connections will be regarded. If not specified, then all accounts will be regarded.
        :type bank_connection_ids: List[int]
        :param min_last_successful_update: <strong>Format:</strong> 'YYYY-MM-DD'<br/>Lower bound for an account's last successful update date, e.g. '2016-01-01'. If specified, then an account will only be regarded if any of its interfaces has a 'lastSuccessfulUpdate' that is equal to or later than the given date.
        :type min_last_successful_update: date
        :param max_last_successful_update: <strong>Format:</strong> 'YYYY-MM-DD'<br/>Upper bound for an account's last successful update date, e.g. '2016-01-01'. If specified, then an account will only be regarded if any of its interfaces has a 'lastSuccessfulUpdate' that is equal to or earlier than the given date.
        :type max_last_successful_update: date
        :param min_balance: If specified, then only accounts whose balance is equal to or greater than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
        :type min_balance: float
        :param max_balance: If specified, then only accounts whose balance is equal to or less than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
        :type max_balance: float
        :param x_request_id: With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_and_search_all_accounts_serialize(
            ids=ids,
            search=search,
            account_types=account_types,
            bank_connection_ids=bank_connection_ids,
            min_last_successful_update=min_last_successful_update,
            max_last_successful_update=max_last_successful_update,
            min_balance=min_balance,
            max_balance=max_balance,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountList",
            '400': "ErrorMessage",
            '401': "BadCredentialsError",
            '403': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_and_search_all_accounts_with_http_info(
        self,
        ids: Annotated[Optional[List[StrictInt]], Field(description="A comma-separated list of account identifiers. If specified, then only accounts whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.")] = None,
        search: Annotated[Optional[StrictStr], Field(description="If specified, then only those accounts will be contained in the result whose 'accountName', 'iban', 'accountNumber' or 'subAccountNumber' contains the given search string (the matching works case-insensitive). If no accounts contain the search string in any of these fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields for an account to get included into the result.")] = None,
        account_types: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of account types. If specified, then only accounts that relate to the given types will be regarded. If not specified, then all accounts will be regarded.")] = None,
        bank_connection_ids: Annotated[Optional[List[StrictInt]], Field(description="A comma-separated list of bank connection identifiers. If specified, then only accounts that relate to the given bank connections will be regarded. If not specified, then all accounts will be regarded.")] = None,
        min_last_successful_update: Annotated[Optional[date], Field(description="<strong>Format:</strong> 'YYYY-MM-DD'<br/>Lower bound for an account's last successful update date, e.g. '2016-01-01'. If specified, then an account will only be regarded if any of its interfaces has a 'lastSuccessfulUpdate' that is equal to or later than the given date.")] = None,
        max_last_successful_update: Annotated[Optional[date], Field(description="<strong>Format:</strong> 'YYYY-MM-DD'<br/>Upper bound for an account's last successful update date, e.g. '2016-01-01'. If specified, then an account will only be regarded if any of its interfaces has a 'lastSuccessfulUpdate' that is equal to or earlier than the given date.")] = None,
        min_balance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="If specified, then only accounts whose balance is equal to or greater than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95")] = None,
        max_balance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="If specified, then only accounts whose balance is equal to or less than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AccountList]:
        """Get and search all accounts

        Get bank accounts of the user that is authorized by the access_token. Must pass the user's access_token. You can set optional search criteria to get only those bank accounts that you are interested in. If you do not specify any search criteria, then this service functions as a 'get all' service.

        :param ids: A comma-separated list of account identifiers. If specified, then only accounts whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
        :type ids: List[int]
        :param search: If specified, then only those accounts will be contained in the result whose 'accountName', 'iban', 'accountNumber' or 'subAccountNumber' contains the given search string (the matching works case-insensitive). If no accounts contain the search string in any of these fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields for an account to get included into the result.
        :type search: str
        :param account_types: A comma-separated list of account types. If specified, then only accounts that relate to the given types will be regarded. If not specified, then all accounts will be regarded.
        :type account_types: List[str]
        :param bank_connection_ids: A comma-separated list of bank connection identifiers. If specified, then only accounts that relate to the given bank connections will be regarded. If not specified, then all accounts will be regarded.
        :type bank_connection_ids: List[int]
        :param min_last_successful_update: <strong>Format:</strong> 'YYYY-MM-DD'<br/>Lower bound for an account's last successful update date, e.g. '2016-01-01'. If specified, then an account will only be regarded if any of its interfaces has a 'lastSuccessfulUpdate' that is equal to or later than the given date.
        :type min_last_successful_update: date
        :param max_last_successful_update: <strong>Format:</strong> 'YYYY-MM-DD'<br/>Upper bound for an account's last successful update date, e.g. '2016-01-01'. If specified, then an account will only be regarded if any of its interfaces has a 'lastSuccessfulUpdate' that is equal to or earlier than the given date.
        :type max_last_successful_update: date
        :param min_balance: If specified, then only accounts whose balance is equal to or greater than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
        :type min_balance: float
        :param max_balance: If specified, then only accounts whose balance is equal to or less than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
        :type max_balance: float
        :param x_request_id: With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_and_search_all_accounts_serialize(
            ids=ids,
            search=search,
            account_types=account_types,
            bank_connection_ids=bank_connection_ids,
            min_last_successful_update=min_last_successful_update,
            max_last_successful_update=max_last_successful_update,
            min_balance=min_balance,
            max_balance=max_balance,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountList",
            '400': "ErrorMessage",
            '401': "BadCredentialsError",
            '403': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_and_search_all_accounts_without_preload_content(
        self,
        ids: Annotated[Optional[List[StrictInt]], Field(description="A comma-separated list of account identifiers. If specified, then only accounts whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.")] = None,
        search: Annotated[Optional[StrictStr], Field(description="If specified, then only those accounts will be contained in the result whose 'accountName', 'iban', 'accountNumber' or 'subAccountNumber' contains the given search string (the matching works case-insensitive). If no accounts contain the search string in any of these fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields for an account to get included into the result.")] = None,
        account_types: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of account types. If specified, then only accounts that relate to the given types will be regarded. If not specified, then all accounts will be regarded.")] = None,
        bank_connection_ids: Annotated[Optional[List[StrictInt]], Field(description="A comma-separated list of bank connection identifiers. If specified, then only accounts that relate to the given bank connections will be regarded. If not specified, then all accounts will be regarded.")] = None,
        min_last_successful_update: Annotated[Optional[date], Field(description="<strong>Format:</strong> 'YYYY-MM-DD'<br/>Lower bound for an account's last successful update date, e.g. '2016-01-01'. If specified, then an account will only be regarded if any of its interfaces has a 'lastSuccessfulUpdate' that is equal to or later than the given date.")] = None,
        max_last_successful_update: Annotated[Optional[date], Field(description="<strong>Format:</strong> 'YYYY-MM-DD'<br/>Upper bound for an account's last successful update date, e.g. '2016-01-01'. If specified, then an account will only be regarded if any of its interfaces has a 'lastSuccessfulUpdate' that is equal to or earlier than the given date.")] = None,
        min_balance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="If specified, then only accounts whose balance is equal to or greater than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95")] = None,
        max_balance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="If specified, then only accounts whose balance is equal to or less than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get and search all accounts

        Get bank accounts of the user that is authorized by the access_token. Must pass the user's access_token. You can set optional search criteria to get only those bank accounts that you are interested in. If you do not specify any search criteria, then this service functions as a 'get all' service.

        :param ids: A comma-separated list of account identifiers. If specified, then only accounts whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
        :type ids: List[int]
        :param search: If specified, then only those accounts will be contained in the result whose 'accountName', 'iban', 'accountNumber' or 'subAccountNumber' contains the given search string (the matching works case-insensitive). If no accounts contain the search string in any of these fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields for an account to get included into the result.
        :type search: str
        :param account_types: A comma-separated list of account types. If specified, then only accounts that relate to the given types will be regarded. If not specified, then all accounts will be regarded.
        :type account_types: List[str]
        :param bank_connection_ids: A comma-separated list of bank connection identifiers. If specified, then only accounts that relate to the given bank connections will be regarded. If not specified, then all accounts will be regarded.
        :type bank_connection_ids: List[int]
        :param min_last_successful_update: <strong>Format:</strong> 'YYYY-MM-DD'<br/>Lower bound for an account's last successful update date, e.g. '2016-01-01'. If specified, then an account will only be regarded if any of its interfaces has a 'lastSuccessfulUpdate' that is equal to or later than the given date.
        :type min_last_successful_update: date
        :param max_last_successful_update: <strong>Format:</strong> 'YYYY-MM-DD'<br/>Upper bound for an account's last successful update date, e.g. '2016-01-01'. If specified, then an account will only be regarded if any of its interfaces has a 'lastSuccessfulUpdate' that is equal to or earlier than the given date.
        :type max_last_successful_update: date
        :param min_balance: If specified, then only accounts whose balance is equal to or greater than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
        :type min_balance: float
        :param max_balance: If specified, then only accounts whose balance is equal to or less than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
        :type max_balance: float
        :param x_request_id: With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_and_search_all_accounts_serialize(
            ids=ids,
            search=search,
            account_types=account_types,
            bank_connection_ids=bank_connection_ids,
            min_last_successful_update=min_last_successful_update,
            max_last_successful_update=max_last_successful_update,
            min_balance=min_balance,
            max_balance=max_balance,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountList",
            '400': "ErrorMessage",
            '401': "BadCredentialsError",
            '403': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_and_search_all_accounts_serialize(
        self,
        ids,
        search,
        account_types,
        bank_connection_ids,
        min_last_successful_update,
        max_last_successful_update,
        min_balance,
        max_balance,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ids': 'multi',
            'accountTypes': 'multi',
            'bankConnectionIds': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if search is not None:
            
            _query_params.append(('search', search))
            
        if account_types is not None:
            
            _query_params.append(('accountTypes', account_types))
            
        if bank_connection_ids is not None:
            
            _query_params.append(('bankConnectionIds', bank_connection_ids))
            
        if min_last_successful_update is not None:
            if isinstance(min_last_successful_update, date):
                _query_params.append(
                    (
                        'minLastSuccessfulUpdate',
                        min_last_successful_update.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('minLastSuccessfulUpdate', min_last_successful_update))
            
        if max_last_successful_update is not None:
            if isinstance(max_last_successful_update, date):
                _query_params.append(
                    (
                        'maxLastSuccessfulUpdate',
                        max_last_successful_update.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('maxLastSuccessfulUpdate', max_last_successful_update))
            
        if min_balance is not None:
            
            _query_params.append(('minBalance', min_balance))
            
        if max_balance is not None:
            
            _query_params.append(('maxBalance', max_balance))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-Id'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'finapi_auth', 
            'finapi_auth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/accounts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_daily_balances(
        self,
        account_ids: Annotated[Optional[List[StrictInt]], Field(description="A comma-separated list of (non-security) account identifiers. If no accounts are specified, all (non-security) accounts of the user are regarded.")] = None,
        start_date: Annotated[Optional[date], Field(description="<strong>Format:</strong> 'YYYY-MM-DD'<br/>Lower bound for the date range to be returned. Note that the requested date range [startDate .. endDate] may not exceed 1 year (366 days - considering Leap Years too).If 'startDate' is not specified, it defaults to 'endDate' minus one month.")] = None,
        end_date: Annotated[Optional[date], Field(description="<strong>Format:</strong> 'YYYY-MM-DD'<br/>Upper bound for the date range to be returned. Note that the requested date range [startDate .. endDate] may not exceed 1 year (366 days - considering Leap Years too). If 'endDate' is not specified, it defaults to today's date.")] = None,
        with_projection: Annotated[Optional[StrictBool], Field(description="Whether finAPI should project the first and last actually existing balance of an account into the past and future. When passing 'true', then the result will always contain a daily balance for every day of the entire requested date range, even for days before the first actually existing balance, resp. after the last actually existing balance. Those days will have the same balance as the day of the first actual balance, resp. last actual balance, i.e. the first/last balance will be infinitely projected into the past/the future. When passing 'false', then the result will contain daily balances only from the day on where the first actual balance exists for any of the regarded accounts, and only up to the day where the last actual balance exists for any of the regarded accounts. Note that when in this case there are no actual balances within the requested date range, then an empty array will be returned. Default value for this parameter is 'true'.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Result page that you want to retrieve.")] = None,
        per_page: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="Maximum number of records per page. By default it's 20.")] = None,
        order: Annotated[Optional[List[StrictStr]], Field(description="Determines the order of the results. You can order the results by 'date', 'balance', 'income' or 'spending'. The default order for this service is 'date,asc'. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: '/accounts/dailyBalances?order=date,desc&order=balance,asc' will return daily balances ordered by 'date' (descending), where items with the same 'date' are ordered by 'balance' (ascending). The general format is: 'property[,asc|desc]', with 'asc' being the default value.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DailyBalanceList:
        """Get daily balances

        Returns the user's daily balances for a given period and a set of specified accounts (or all accounts, if none are specified). The daily balances are calculated by finAPI and are based on the current balances of the regarded accounts.<br/><br/>NOTES:<br/>&bull; This service is not calculating exchange rates for transactions, so if an account contains any transactions with a currency different to the account's currency, then the service is unable to provide accurate data.<br/>&bull; This service may return incorrect results if the 'skipBalancesDownload' and/or the 'skipPositionsDownload' flag have been set to true during an import, update or connect interface service call.

        :param account_ids: A comma-separated list of (non-security) account identifiers. If no accounts are specified, all (non-security) accounts of the user are regarded.
        :type account_ids: List[int]
        :param start_date: <strong>Format:</strong> 'YYYY-MM-DD'<br/>Lower bound for the date range to be returned. Note that the requested date range [startDate .. endDate] may not exceed 1 year (366 days - considering Leap Years too).If 'startDate' is not specified, it defaults to 'endDate' minus one month.
        :type start_date: date
        :param end_date: <strong>Format:</strong> 'YYYY-MM-DD'<br/>Upper bound for the date range to be returned. Note that the requested date range [startDate .. endDate] may not exceed 1 year (366 days - considering Leap Years too). If 'endDate' is not specified, it defaults to today's date.
        :type end_date: date
        :param with_projection: Whether finAPI should project the first and last actually existing balance of an account into the past and future. When passing 'true', then the result will always contain a daily balance for every day of the entire requested date range, even for days before the first actually existing balance, resp. after the last actually existing balance. Those days will have the same balance as the day of the first actual balance, resp. last actual balance, i.e. the first/last balance will be infinitely projected into the past/the future. When passing 'false', then the result will contain daily balances only from the day on where the first actual balance exists for any of the regarded accounts, and only up to the day where the last actual balance exists for any of the regarded accounts. Note that when in this case there are no actual balances within the requested date range, then an empty array will be returned. Default value for this parameter is 'true'.
        :type with_projection: bool
        :param page: Result page that you want to retrieve.
        :type page: int
        :param per_page: Maximum number of records per page. By default it's 20.
        :type per_page: int
        :param order: Determines the order of the results. You can order the results by 'date', 'balance', 'income' or 'spending'. The default order for this service is 'date,asc'. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: '/accounts/dailyBalances?order=date,desc&order=balance,asc' will return daily balances ordered by 'date' (descending), where items with the same 'date' are ordered by 'balance' (ascending). The general format is: 'property[,asc|desc]', with 'asc' being the default value.
        :type order: List[str]
        :param x_request_id: With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_daily_balances_serialize(
            account_ids=account_ids,
            start_date=start_date,
            end_date=end_date,
            with_projection=with_projection,
            page=page,
            per_page=per_page,
            order=order,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DailyBalanceList",
            '400': "ErrorMessage",
            '401': "BadCredentialsError",
            '403': "ErrorMessage",
            '404': "ErrorMessage",
            '422': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_daily_balances_with_http_info(
        self,
        account_ids: Annotated[Optional[List[StrictInt]], Field(description="A comma-separated list of (non-security) account identifiers. If no accounts are specified, all (non-security) accounts of the user are regarded.")] = None,
        start_date: Annotated[Optional[date], Field(description="<strong>Format:</strong> 'YYYY-MM-DD'<br/>Lower bound for the date range to be returned. Note that the requested date range [startDate .. endDate] may not exceed 1 year (366 days - considering Leap Years too).If 'startDate' is not specified, it defaults to 'endDate' minus one month.")] = None,
        end_date: Annotated[Optional[date], Field(description="<strong>Format:</strong> 'YYYY-MM-DD'<br/>Upper bound for the date range to be returned. Note that the requested date range [startDate .. endDate] may not exceed 1 year (366 days - considering Leap Years too). If 'endDate' is not specified, it defaults to today's date.")] = None,
        with_projection: Annotated[Optional[StrictBool], Field(description="Whether finAPI should project the first and last actually existing balance of an account into the past and future. When passing 'true', then the result will always contain a daily balance for every day of the entire requested date range, even for days before the first actually existing balance, resp. after the last actually existing balance. Those days will have the same balance as the day of the first actual balance, resp. last actual balance, i.e. the first/last balance will be infinitely projected into the past/the future. When passing 'false', then the result will contain daily balances only from the day on where the first actual balance exists for any of the regarded accounts, and only up to the day where the last actual balance exists for any of the regarded accounts. Note that when in this case there are no actual balances within the requested date range, then an empty array will be returned. Default value for this parameter is 'true'.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Result page that you want to retrieve.")] = None,
        per_page: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="Maximum number of records per page. By default it's 20.")] = None,
        order: Annotated[Optional[List[StrictStr]], Field(description="Determines the order of the results. You can order the results by 'date', 'balance', 'income' or 'spending'. The default order for this service is 'date,asc'. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: '/accounts/dailyBalances?order=date,desc&order=balance,asc' will return daily balances ordered by 'date' (descending), where items with the same 'date' are ordered by 'balance' (ascending). The general format is: 'property[,asc|desc]', with 'asc' being the default value.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DailyBalanceList]:
        """Get daily balances

        Returns the user's daily balances for a given period and a set of specified accounts (or all accounts, if none are specified). The daily balances are calculated by finAPI and are based on the current balances of the regarded accounts.<br/><br/>NOTES:<br/>&bull; This service is not calculating exchange rates for transactions, so if an account contains any transactions with a currency different to the account's currency, then the service is unable to provide accurate data.<br/>&bull; This service may return incorrect results if the 'skipBalancesDownload' and/or the 'skipPositionsDownload' flag have been set to true during an import, update or connect interface service call.

        :param account_ids: A comma-separated list of (non-security) account identifiers. If no accounts are specified, all (non-security) accounts of the user are regarded.
        :type account_ids: List[int]
        :param start_date: <strong>Format:</strong> 'YYYY-MM-DD'<br/>Lower bound for the date range to be returned. Note that the requested date range [startDate .. endDate] may not exceed 1 year (366 days - considering Leap Years too).If 'startDate' is not specified, it defaults to 'endDate' minus one month.
        :type start_date: date
        :param end_date: <strong>Format:</strong> 'YYYY-MM-DD'<br/>Upper bound for the date range to be returned. Note that the requested date range [startDate .. endDate] may not exceed 1 year (366 days - considering Leap Years too). If 'endDate' is not specified, it defaults to today's date.
        :type end_date: date
        :param with_projection: Whether finAPI should project the first and last actually existing balance of an account into the past and future. When passing 'true', then the result will always contain a daily balance for every day of the entire requested date range, even for days before the first actually existing balance, resp. after the last actually existing balance. Those days will have the same balance as the day of the first actual balance, resp. last actual balance, i.e. the first/last balance will be infinitely projected into the past/the future. When passing 'false', then the result will contain daily balances only from the day on where the first actual balance exists for any of the regarded accounts, and only up to the day where the last actual balance exists for any of the regarded accounts. Note that when in this case there are no actual balances within the requested date range, then an empty array will be returned. Default value for this parameter is 'true'.
        :type with_projection: bool
        :param page: Result page that you want to retrieve.
        :type page: int
        :param per_page: Maximum number of records per page. By default it's 20.
        :type per_page: int
        :param order: Determines the order of the results. You can order the results by 'date', 'balance', 'income' or 'spending'. The default order for this service is 'date,asc'. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: '/accounts/dailyBalances?order=date,desc&order=balance,asc' will return daily balances ordered by 'date' (descending), where items with the same 'date' are ordered by 'balance' (ascending). The general format is: 'property[,asc|desc]', with 'asc' being the default value.
        :type order: List[str]
        :param x_request_id: With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_daily_balances_serialize(
            account_ids=account_ids,
            start_date=start_date,
            end_date=end_date,
            with_projection=with_projection,
            page=page,
            per_page=per_page,
            order=order,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DailyBalanceList",
            '400': "ErrorMessage",
            '401': "BadCredentialsError",
            '403': "ErrorMessage",
            '404': "ErrorMessage",
            '422': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_daily_balances_without_preload_content(
        self,
        account_ids: Annotated[Optional[List[StrictInt]], Field(description="A comma-separated list of (non-security) account identifiers. If no accounts are specified, all (non-security) accounts of the user are regarded.")] = None,
        start_date: Annotated[Optional[date], Field(description="<strong>Format:</strong> 'YYYY-MM-DD'<br/>Lower bound for the date range to be returned. Note that the requested date range [startDate .. endDate] may not exceed 1 year (366 days - considering Leap Years too).If 'startDate' is not specified, it defaults to 'endDate' minus one month.")] = None,
        end_date: Annotated[Optional[date], Field(description="<strong>Format:</strong> 'YYYY-MM-DD'<br/>Upper bound for the date range to be returned. Note that the requested date range [startDate .. endDate] may not exceed 1 year (366 days - considering Leap Years too). If 'endDate' is not specified, it defaults to today's date.")] = None,
        with_projection: Annotated[Optional[StrictBool], Field(description="Whether finAPI should project the first and last actually existing balance of an account into the past and future. When passing 'true', then the result will always contain a daily balance for every day of the entire requested date range, even for days before the first actually existing balance, resp. after the last actually existing balance. Those days will have the same balance as the day of the first actual balance, resp. last actual balance, i.e. the first/last balance will be infinitely projected into the past/the future. When passing 'false', then the result will contain daily balances only from the day on where the first actual balance exists for any of the regarded accounts, and only up to the day where the last actual balance exists for any of the regarded accounts. Note that when in this case there are no actual balances within the requested date range, then an empty array will be returned. Default value for this parameter is 'true'.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Result page that you want to retrieve.")] = None,
        per_page: Annotated[Optional[Annotated[int, Field(le=500, strict=True, ge=1)]], Field(description="Maximum number of records per page. By default it's 20.")] = None,
        order: Annotated[Optional[List[StrictStr]], Field(description="Determines the order of the results. You can order the results by 'date', 'balance', 'income' or 'spending'. The default order for this service is 'date,asc'. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: '/accounts/dailyBalances?order=date,desc&order=balance,asc' will return daily balances ordered by 'date' (descending), where items with the same 'date' are ordered by 'balance' (ascending). The general format is: 'property[,asc|desc]', with 'asc' being the default value.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get daily balances

        Returns the user's daily balances for a given period and a set of specified accounts (or all accounts, if none are specified). The daily balances are calculated by finAPI and are based on the current balances of the regarded accounts.<br/><br/>NOTES:<br/>&bull; This service is not calculating exchange rates for transactions, so if an account contains any transactions with a currency different to the account's currency, then the service is unable to provide accurate data.<br/>&bull; This service may return incorrect results if the 'skipBalancesDownload' and/or the 'skipPositionsDownload' flag have been set to true during an import, update or connect interface service call.

        :param account_ids: A comma-separated list of (non-security) account identifiers. If no accounts are specified, all (non-security) accounts of the user are regarded.
        :type account_ids: List[int]
        :param start_date: <strong>Format:</strong> 'YYYY-MM-DD'<br/>Lower bound for the date range to be returned. Note that the requested date range [startDate .. endDate] may not exceed 1 year (366 days - considering Leap Years too).If 'startDate' is not specified, it defaults to 'endDate' minus one month.
        :type start_date: date
        :param end_date: <strong>Format:</strong> 'YYYY-MM-DD'<br/>Upper bound for the date range to be returned. Note that the requested date range [startDate .. endDate] may not exceed 1 year (366 days - considering Leap Years too). If 'endDate' is not specified, it defaults to today's date.
        :type end_date: date
        :param with_projection: Whether finAPI should project the first and last actually existing balance of an account into the past and future. When passing 'true', then the result will always contain a daily balance for every day of the entire requested date range, even for days before the first actually existing balance, resp. after the last actually existing balance. Those days will have the same balance as the day of the first actual balance, resp. last actual balance, i.e. the first/last balance will be infinitely projected into the past/the future. When passing 'false', then the result will contain daily balances only from the day on where the first actual balance exists for any of the regarded accounts, and only up to the day where the last actual balance exists for any of the regarded accounts. Note that when in this case there are no actual balances within the requested date range, then an empty array will be returned. Default value for this parameter is 'true'.
        :type with_projection: bool
        :param page: Result page that you want to retrieve.
        :type page: int
        :param per_page: Maximum number of records per page. By default it's 20.
        :type per_page: int
        :param order: Determines the order of the results. You can order the results by 'date', 'balance', 'income' or 'spending'. The default order for this service is 'date,asc'. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: '/accounts/dailyBalances?order=date,desc&order=balance,asc' will return daily balances ordered by 'date' (descending), where items with the same 'date' are ordered by 'balance' (ascending). The general format is: 'property[,asc|desc]', with 'asc' being the default value.
        :type order: List[str]
        :param x_request_id: With any API call, you can pass a request ID. The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error. If you don't pass a request ID for a call, finAPI will generate a random ID internally. The request ID is always returned back in the response of a service, as a header with name 'X-Request-Id'. We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response (especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_daily_balances_serialize(
            account_ids=account_ids,
            start_date=start_date,
            end_date=end_date,
            with_projection=with_projection,
            page=page,
            per_page=per_page,
            order=order,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DailyBalanceList",
            '400': "ErrorMessage",
            '401': "BadCredentialsError",
            '403': "ErrorMessage",
            '404': "ErrorMessage",
            '422': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_daily_balances_serialize(
        self,
        account_ids,
        start_date,
        end_date,
        with_projection,
        page,
        per_page,
        order,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'accountIds': 'multi',
            'order': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_ids is not None:
            
            _query_params.append(('accountIds', account_ids))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'startDate',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'endDate',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('endDate', end_date))
            
        if with_projection is not None:
            
            _query_params.append(('withProjection', with_projection))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if per_page is not None:
            
            _query_params.append(('perPage', per_page))
            
        if order is not None:
            
            _query_params.append(('order', order))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-Id'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'finapi_auth', 
            'finapi_auth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/accounts/dailyBalances',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


